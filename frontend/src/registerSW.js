// Enhanced Service Worker Registration and Update Checking
// Works directly with vite-plugin-pwa generated service worker

export function setupUpdateChecker() {
    // Return a promise that resolves with the registration when available
    if (!('serviceWorker' in navigator)) {
      console.log('\u2139\ufe0f Service Workers not supported in this browser');
      return Promise.resolve(null);
    }

    return new Promise((resolve, reject) => {
      // Register on load to avoid racing with app boot
      window.addEventListener('load', async () => {
        try {
          // Register the service worker generated by vite-plugin-pwa
          const registration = await navigator.serviceWorker.register('/sw.js', {
            scope: '/',
            updateViaCache: 'none' // always check for updates, don't use cached service worker
          });

          console.log('\u2705 Service Worker registered successfully');

          // Helper: perform a registration update check
          const checkForUpdates = () => {
            try {
              console.log('\ud83d\udd04 Checking for updates...');
              registration.update().catch(err => {
                if (err && err.message && err.message.includes('403')) {
                  console.log('\u2139\ufe0f No updates available (403 - normal for unchanged content)');
                } else {
                  console.warn('Update check failed:', err);
                }
              });
            } catch (err) {
              console.warn('checkForUpdates error:', err);
            }
          };

          // Initial update check after registration
          setTimeout(checkForUpdates, 2000);

          // Periodic checks and user-triggered checks
          const updateInterval = setInterval(checkForUpdates, 300000); // 5 minutes
          document.addEventListener('visibilitychange', () => { if (!document.hidden) checkForUpdates(); });
          window.addEventListener('focus', checkForUpdates);

          // Listen for updates
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            console.log('\ud83c\udd95 New version found, installing...');

            if (newWorker) {
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed') {
                  if (navigator.serviceWorker.controller) {
                    // New content is available
                    console.log('\u2728 New version installed! Notifying and attempting to activate.');
                    showUpdateNotification();
                    // Ask the waiting worker to activate
                    try {
                      newWorker.postMessage({ type: 'SKIP_WAITING' });
                    } catch (e) {
                      console.warn('Failed to postMessage to new worker:', e);
                    }
                  } else {
                    // First time installation
                    console.log('\u2705 App is ready for offline use');
                  }
                }
              });
            }
          });

          // Handle controller change (when skipWaiting is used)
          let refreshing = false;
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (refreshing) return;
            refreshing = true;
            console.log('\ud83d\udd04 Service Worker controller changed - reloading page');
            window.location.reload();
          });

          // Handle messages from service worker
          navigator.serviceWorker.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'SW_UPDATED') {
              console.log('\ud83d\udd04 Service Worker updated (message), reloading...');
              window.location.reload();
            }
          });

          // Keep a way to clean up periodic checks if needed
          // Expose an API on the registration to stop internal intervals (not standard, safe to attach)
          try {
            registration._pwaUpdateInterval = updateInterval;
          } catch (e) {
            // ignore
          }

          resolve(registration);
        } catch (error) {
          console.error('\u274c Service Worker registration failed:', error);
          reject(error);
        }
      }, { once: true });
    });
  }
function showUpdateNotification() {
  // Create a simple toast notification
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #14B8A6;
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    z-index: 10000;
    font-family: system-ui, -apple-system, sans-serif;
    font-size: 14px;
    font-weight: 500;
    animation: slideDown 0.3s ease-out;
  `;
  notification.textContent = '🎉 App updated! Reloading...';
  
  // Add animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes slideDown {
      from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }
  `;
  document.head.appendChild(style);
  document.body.appendChild(notification);
  
  // Remove after 2 seconds (before reload)
  setTimeout(() => {
    notification.remove();
  }, 2000);
}

export async function clearAllCaches() {
  if ('caches' in window) {
    const cacheNames = await caches.keys();
    await Promise.all(cacheNames.map((name) => caches.delete(name)));
    console.log('🗑️ All caches cleared');
  }
}

export async function checkForUpdates() {
  if ('serviceWorker' in navigator) {
    const registration = await navigator.serviceWorker.getRegistration();
    if (registration) {
      console.log('🔍 Manual update check triggered');
      await registration.update();
    }
  }
}
